parm = Initial.Values
estimates <- optim(parm, LogPost, Data=Data, Model=Model, method = "SANN",
control=list(maxit=maxit, temp=temp, tmax=tmax,
trace=2, REPORT=REPORT))
Model(estimates$par, Data)
plot(estimates$par[Data$parm.names])
plot(estimates$par[1:20])
plot(estimates$par[1:20] ~ data$abil)
cor(estimates$par[1:20] ~ data$abil)
cor(estimates$par[1:20], data$abil)
cor(estimates$par[1:20], data$abil, method+ 's')
cor(estimates$par[1:20], data$abil, method='s')
Fit <- estimates
Fit <- Model(estimates$par, Data)
abil = Fit$parm[pos.theta]
diff = Fit$parm[pos.b]
Dev  = Fit$Dev
DIC  = list(DIC=mean(Dev) + var(Dev)/2, Dbar=mean(Dev), pV=var(Dev)/2)
DIC
Fit$Monitor
Fit$LP
method = "MAP"
### Start====
require(LaplacesDemon)
require(compiler)
require(parallel)
require(tidyr)
CPUs = detectCores(all.tests = FALSE, logical = TRUE) - 1
if(CPUs == 0) CPUs = 1
### Convert data to long format====
lonlong <- gather(data.frame(x), item, resp, colnames(x), factor_key=TRUE)
data_long <- data.frame(ID=rep(1:nrow(x), times=ncol(x)),lonlong)
### Choose a model====
if (interaction == F) {
### Rasch model
# Assemble data list
if (method == "MAP") {
mon.names  <- "LL"
} else { mon.names  <- "LP" }
parm.names <- as.parm.names(list( theta=rep(0,nrow(x)), b=rep(0,ncol(x)) ))
pos.theta  <- grep("theta", parm.names)
pos.b      <- grep("b", parm.names)
PGF <- function(Data) {
theta <- rnorm(Data$n)
b     <- rnorm(Data$v)
return(c(theta, b))
}
MyData <- list(parm.names=parm.names, mon.names=mon.names,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x),
pos.theta=pos.theta, pos.b=pos.b)
is.data(MyData)
# Model
Model <- function(parm, Data){
## Prior parameters
theta <- parm[Data$pos.theta]
b     <- parm[Data$pos.b]
### Log-Priors
theta.prior <- sum(dnorm(theta, mean=0, sd=1, log=TRUE))
b.prior     <- sum(dnorm(b, mean=0, sd=1, log=T))
Lpp <- theta.prior + b.prior
### Log-Likelihood
thetaLL <- rep(theta, times=Data$v)
bLL     <- rep(b    , each=Data$n)
IRF     <- plogis( thetaLL - bLL )
LL      <- sum( dbinom(Data$X[,3], size=1, prob=IRF, log=T) )
### Log-Posterior
LP <- LL + Lpp
### Estimates
yhat <- rbinom(length(IRF), size=1, prob=IRF)
### Output
Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=yhat, parm=parm)
return(Modelout)
}
Model <- compiler::cmpfun(Model)
Initial.Values <- GIV(Model, MyData, PGF=T)
is.model(Model, Initial.Values, MyData)
is.bayesian(Model, Initial.Values, MyData)
} else if (interaction == T) {
### Rasch Interaction model
# Assemble data list
mon.names  <- "LP"
parm.names <- as.parm.names(list( theta=rep(0,nrow(x)),
b=rep(0,ncol(x)),
delta=rep(0,1) ))
pos.theta  <- grep("theta", parm.names)
pos.b      <- grep("b", parm.names)
pos.delta  <- grep("delta", parm.names)
PGF <- function(Data) {
theta <- rnorm(Data$n)
b     <- rnorm(Data$v)
delta <- rnorm(1, 0, 1)
return(c(theta, b, delta))
}
MyData <- list(parm.names=parm.names, mon.names=mon.names,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x),
pos.theta=pos.theta, pos.b=pos.b, pos.delta=pos.delta)
is.data(MyData)
# Model
Model <- function(parm, Data){
## Prior parameters
theta <- parm[Data$pos.theta]
b     <- parm[Data$pos.b]
delta <- parm[Data$pos.delta]
### Log-Priors
theta.prior <- sum(dnorm(theta, mean=0, sd=1, log=T))
b.prior     <- sum(dnorm(b, mean=0, sd=1, log=T))
delta.prior <- sum(dnorm(delta, mean=0, sd=1, log=T))
Lpp <- theta.prior + b.prior + delta.prior
### Log-Likelihood
thetaLL <- rep(theta, times=Data$v)
bLL     <- rep(b    , each=Data$n)
deltaLL <- rep(delta, each=Data$n * Data$v)
IRF     <- plogis( thetaLL + bLL + (deltaLL * thetaLL * bLL) )
LL      <- sum( dbinom(Data$X[,3], size=1, prob=IRF, log=T) )
### Log-Posterior
LP <- LL + Lpp
### Estimates
yhat <- rbinom(length(IRF), size=1, prob=IRF)
### Output
Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=yhat, parm=parm)
return(Modelout)
}
Model <- compiler::cmpfun(Model)
Initial.Values <- GIV(Model, MyData, PGF=T)
is.model(Model, Initial.Values, MyData)
is.bayesian(Model, Initial.Values, MyData)
} else stop("Unknow model :(")
Iters = 65000
## Maximum a Posteriori====
#Iters=100; Smpl=1000
Iters=Iters; Status=Iters/10
Fit <- MAP(Model=Model, parm=Initial.Values, Data=MyData,
maxit=Iters, temp=temp, tmax=tmax, REPORT=Status)
MAP <- function(Model, parm, Data, maxit=65000, temp=1e-2, tmax=1, REPORT=1000) {
print("Initiating MAP estimation with SANN algorithm")
Sys.sleep(2)
LogPost <- function(para, Model, Data) {
LP <- Model(para[1:length(Data$parm.names)], Data)
-LP$LP
}
estimates <- optim(parm, LogPost, Data=Data, Model=Model, method = "SANN",
control=list(maxit=maxit, temp=temp, tmax=tmax,
trace=2, REPORT=REPORT))
return(Model(estimates$par, Data))
}
Fit <- MAP(Model=Model, parm=Initial.Values, Data=MyData,
maxit=Iters, temp=temp, tmax=tmax, REPORT=Status)
Fit
AIC(-126.9692)
log(nrow(x)) * length(parm.names)
log(nrow(x)) * length(parm.names) - (2 * Fit$Monitor)
(log(nrow(x)) * length(parm.names)) - (2 * Fit$Monitor)
?hist
p=1
levels
levels = 2
x <- x + 1
### Start====
require(LaplacesDemon)
require(compiler)
require(parallel)
require(tidyr)
require(matrixStats)
CPUs = detectCores(all.tests = FALSE, logical = TRUE) - 1
if(CPUs == 0) CPUs = 1
### Convert data to long format====
if (is.null(levels)) levels <- max(x)
lonlong <- gather(data.frame(x), item, resp, colnames(x), factor_key=TRUE)
data_long <- data.frame(ID=rep(1:nrow(x), times=ncol(x)),lonlong)
### Choose model====
if (p == 1) {
## Partial Credit Model====
# Assemble data list
mon.names  <- "LP"
parm.names <- as.parm.names(list( theta=rep(0,nrow(x)), b=rep(0,ncol(x) * levels) ))
pos.theta  <- grep("theta", parm.names)
pos.b      <- grep("b", parm.names)
PGF <- function(Data) {
theta <- rnorm(Data$n)
b     <- rnorm(Data$v * Data$levels)
return(c(theta, b))
}
MyData <- list(parm.names=parm.names, mon.names=mon.names,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x), levels=levels,
pos.theta=pos.theta, pos.b=pos.b)
is.data(MyData)
# Model
Model <- function(parm, Data){
## Prior parameters
theta <- parm[Data$pos.theta]
b     <- parm[Data$pos.b]
### Log-Priors
theta.prior <- sum(dnorm(theta, mean=0, sd=1, log=T))
b.prior     <- sum(dnorm(b    , mean=0, sd=1, log=T))
Lpp <- theta.prior + b.prior
### Log-Likelihood
thetaLL  <- rep(theta, times=Data$v)
BsL      <- rep(b    , each=Data$n)
bLL      <- matrix(BsL , nrow=nrow(Data$X), ncol=Data$levels)
eta      <- thetaLL - bLL
exp.psum <- exp(matrixStats::rowCumsums(eta))
IRF      <- exp.psum / rowSums(exp.psum)
LL       <- sum( dcat(Data$X[,3], p=IRF, log=T) )
### Log-Posterior
LP <- LL + Lpp
### Estimates
yhat <- rcat(nrow(IRF),p=IRF)
### Output
Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=yhat, parm=parm)
return(Modelout)
}
Model <- compiler::cmpfun(Model)
Initial.Values <- GIV(Model, MyData, PGF=T)
is.model(Model, Initial.Values, MyData)
is.bayesian(Model, Initial.Values, MyData)
} else if (p == 2) {
## Generalized Partial Credit Model====
# Assemble data list
mon.names  <- "LP"
parm.names <- as.parm.names(list( theta=rep(0,nrow(x)), b=rep(0,ncol(x) * levels),
Ds=rep(0,ncol(x)) ))
pos.theta  <- grep("theta", parm.names)
pos.b      <- grep("b", parm.names)
pos.Ds    <- grep("Ds", parm.names)
PGF <- function(Data) {
theta <- rnorm(Data$n)
b     <- rnorm(Data$v * Data$levels)
Ds    <- rnorm(Data$v)
return(c(theta, b, Ds))
}
MyData <- list(parm.names=parm.names, mon.names=mon.names,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x), levels=levels,
pos.theta=pos.theta, pos.b=pos.b, pos.Ds=pos.Ds)
is.data(MyData)
# Model
Model <- function(parm, Data){
## Prior parameters
theta <- parm[Data$pos.theta]
b     <- parm[Data$pos.b]
Ds    <- parm[Data$pos.Ds]
### Log-Priors
theta.prior <- sum(dnorm(theta, mean=0, sd=1, log=T))
b.prior     <- sum(dnorm(b    , mean=0, sd=1, log=T))
Ds.prior    <- sum(dnorm(Ds   , mean=0, sd=1, log=T))
Lpp <- theta.prior + b.prior + Ds.prior
### Log-Likelihood
thetaLL  <- rep(theta, times=Data$v)
BsL      <- rep(b    , each=Data$n)
bLL      <- matrix(BsL , nrow=nrow(Data$X), ncol=Data$levels)
DLL      <- rep(Ds   , each=Data$n)
eta      <- DLL * (thetaLL - bLL)
exp.psum <- exp(matrixStats::rowCumsums(eta))
IRF      <- exp.psum / rowSums(exp.psum)
LL       <- sum( dcat(Data$X[,3], p=IRF, log=T) )
### Log-Posterior
LP <- LL + Lpp
### Estimates
yhat <- rcat(nrow(IRF),p=IRF)
### Output
Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=yhat, parm=parm)
return(Modelout)
}
Model <- compiler::cmpfun(Model)
Initial.Values <- GIV(Model, MyData, PGF=T)
is.model(Model, Initial.Values, MyData)
is.bayesian(Model, Initial.Values, MyData)
} else warning("Unknow model :(")
Fit <- MAP(Model=Model, parm=Initial.Values, Data=MyData,
maxit=Iters, temp=temp, tmax=tmax, REPORT=Status)
abil = Fit$parm[pos.theta]
diff = matrix(Fit$parm[pos.b], nrow=ncol(x))
rownames(diff) = colnames(x)
colnames(diff) = paste("Answer_Key",1:levels,sep="_")
BIC  = (log(nrow(x)) * length(parm.names)) - (2 * Fit$Monitor)
abil
diff
BIC
method
### Start====
require(LaplacesDemon)
require(compiler)
require(parallel)
require(tidyr)
CPUs = detectCores(all.tests = FALSE, logical = TRUE) - 1
if(CPUs == 0) CPUs = 1
### Convert data to long format====
if (is.null(levels)) levels <- max(x) + 1
knots <- seq(0, 1, len=knot)
base_score <- as.vector(scale(rowMeans(x), center=(levels - 1) * .5))
var_bscore <- (pnorm(base_score) * (1 - pnorm(base_score)) ) * (levels - 1)
if (is.null(basis)) {
len_basis = length(knots) + 3
} else if (basis == "b-spline") {
len_basis = length(knots) + 3
} else if (basis == "rademacher") {
len_basis = length(knots)
} else { stop("Unkown basis :(") }
lonlong <- gather(data.frame(x), item, resp, colnames(x), factor_key=TRUE)
data_long <- data.frame(ID=rep(1:nrow(x), times=ncol(x)),lonlong)
### Assemble data list====
if (method == "MAP") {
mon.names  <- "LL"
} else { mon.names  <- "LP" }
parm.names <- as.parm.names(list( theta=rep(0,nrow(x)),
b=rep(0,ncol(x) * len_basis) ))
pos.theta  <- grep("theta", parm.names)
pos.b      <- grep("b", parm.names)
PGF <- function(Data) {
theta <- rnorm(Data$n)
b     <- rlaplace(Data$len_basis * Data$v)
return(c(theta, b))
}
MyData <- list(parm.names=parm.names, mon.names=mon.names, levels=levels,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x), len_basis=len_basis,
base_score=base_score, var_bscore=var_bscore,
pos.theta=pos.theta, pos.b=pos.b, knots=knots)
is.data(MyData)
### Model====
Model <- function(parm, Data){
## Prior parameters
theta <- parm[Data$pos.theta]
b     <- parm[Data$pos.b]
### Log-Priors
theta.prior <- sum(dnorm(theta, mean=Data$base_score, sd=sqrt(Data$var_bscore), log=T))
b.prior     <- sum(dlaplace(b, location=0, scale=10, log=T))
Lpp <- theta.prior + b.prior
### Log-Likelihood
thetaLL <- pnorm( rep(theta, times=Data$v) )
BsL     <- rep(b    , each=Data$n)
bLL     <- matrix(BsL , nrow=nrow(Data$X), ncol=Data$len_basis)
#kLL     <- t(matrix(knots, nrow=Data$len_basis, ncol=nrow(Data$X)))
if (is.null(basis)) {
kLL <- as.matrix(splines::bs(thetaLL, knots=Data$knots))
if (is.null(irf)) {
IRF     <- plogis( rowSums( kLL * bLL ) )
} else if (irf == "logit") {
IRF     <- plogis( rowSums( kLL * bLL ) )
} else if (irf == "sirm") {
IRF     <- 1 / (1 + exp(rowSums( kLL * bLL )))
} else { stop("Unkown IRF :(") }
} else if (basis == "b-spline") {
kLL <- as.matrix(splines::bs(thetaLL, knots=Data$knots))
if (is.null(irf)) {
IRF     <- plogis( rowSums( kLL * bLL ) )
} else if (irf == "logit") {
IRF     <- plogis( rowSums( kLL * bLL ) )
} else if (irf == "sirm") {
IRF     <- 1 / (1 + exp(rowSums( kLL * bLL )))
} else { stop("Unkown IRF :(") }
} else if (basis == "rademacher") {
nKK <- Data$knots
KK  <- t(matrix(nKK, nrow=length(nKK), ncol=length(thetaLL)))
W   <- rowSums((((thetaLL < KK) * -2) + 1) * bLL)
if (is.null(irf)) {
IRF     <- plogis( W )
} else if (irf == "logit") {
IRF     <- plogis( W )
} else if (irf == "sirm") {
IRF     <- 1 / (1 + exp(W))
} else { stop("Unkown IRF :(") }
} else { stop("Unkown basis :(") }
LL      <- sum( dbinom(Data$X[,3], size=(Data$levels - 1), prob=IRF, log=T) )
### Log-Posterior
LP <- LL + Lpp
### Estimates
yhat <- rbinom(length(IRF), size=(Data$levels - 1), prob=IRF)
### Output
Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=yhat, parm=parm)
return(Modelout)
}
Model <- compiler::cmpfun(Model)
Initial.Values <- GIV(Model, MyData, PGF=T)
is.model(Model, Initial.Values, MyData)
is.bayesian(Model, Initial.Values, MyData)
levels=NULL; basis=NULL; knot=10; irf=NULL
x <- x - 1
x
levels=NULL; basis=NULL; knot=10; irf=NULL
### Start====
require(LaplacesDemon)
require(compiler)
require(parallel)
require(tidyr)
CPUs = detectCores(all.tests = FALSE, logical = TRUE) - 1
if(CPUs == 0) CPUs = 1
### Convert data to long format====
if (is.null(levels)) levels <- max(x) + 1
knots <- seq(0, 1, len=knot)
base_score <- as.vector(scale(rowMeans(x), center=(levels - 1) * .5))
var_bscore <- (pnorm(base_score) * (1 - pnorm(base_score)) ) * (levels - 1)
if (is.null(basis)) {
len_basis = length(knots) + 3
} else if (basis == "b-spline") {
len_basis = length(knots) + 3
} else if (basis == "rademacher") {
len_basis = length(knots)
} else { stop("Unkown basis :(") }
lonlong <- gather(data.frame(x), item, resp, colnames(x), factor_key=TRUE)
data_long <- data.frame(ID=rep(1:nrow(x), times=ncol(x)),lonlong)
### Assemble data list====
if (method == "MAP") {
mon.names  <- "LL"
} else { mon.names  <- "LP" }
parm.names <- as.parm.names(list( theta=rep(0,nrow(x)),
b=rep(0,ncol(x) * len_basis) ))
pos.theta  <- grep("theta", parm.names)
pos.b      <- grep("b", parm.names)
PGF <- function(Data) {
theta <- rnorm(Data$n)
b     <- rlaplace(Data$len_basis * Data$v)
return(c(theta, b))
}
MyData <- list(parm.names=parm.names, mon.names=mon.names, levels=levels,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x), len_basis=len_basis,
base_score=base_score, var_bscore=var_bscore,
pos.theta=pos.theta, pos.b=pos.b, knots=knots)
is.data(MyData)
### Model====
Model <- function(parm, Data){
## Prior parameters
theta <- parm[Data$pos.theta]
b     <- parm[Data$pos.b]
### Log-Priors
theta.prior <- sum(dnorm(theta, mean=Data$base_score, sd=sqrt(Data$var_bscore), log=T))
b.prior     <- sum(dlaplace(b, location=0, scale=10, log=T))
Lpp <- theta.prior + b.prior
### Log-Likelihood
thetaLL <- pnorm( rep(theta, times=Data$v) )
BsL     <- rep(b    , each=Data$n)
bLL     <- matrix(BsL , nrow=nrow(Data$X), ncol=Data$len_basis)
#kLL     <- t(matrix(knots, nrow=Data$len_basis, ncol=nrow(Data$X)))
if (is.null(basis)) {
kLL <- as.matrix(splines::bs(thetaLL, knots=Data$knots))
if (is.null(irf)) {
IRF     <- plogis( rowSums( kLL * bLL ) )
} else if (irf == "logit") {
IRF     <- plogis( rowSums( kLL * bLL ) )
} else if (irf == "sirm") {
IRF     <- 1 / (1 + exp(rowSums( kLL * bLL )))
} else { stop("Unkown IRF :(") }
} else if (basis == "b-spline") {
kLL <- as.matrix(splines::bs(thetaLL, knots=Data$knots))
if (is.null(irf)) {
IRF     <- plogis( rowSums( kLL * bLL ) )
} else if (irf == "logit") {
IRF     <- plogis( rowSums( kLL * bLL ) )
} else if (irf == "sirm") {
IRF     <- 1 / (1 + exp(rowSums( kLL * bLL )))
} else { stop("Unkown IRF :(") }
} else if (basis == "rademacher") {
nKK <- Data$knots
KK  <- t(matrix(nKK, nrow=length(nKK), ncol=length(thetaLL)))
W   <- rowSums((((thetaLL < KK) * -2) + 1) * bLL)
if (is.null(irf)) {
IRF     <- plogis( W )
} else if (irf == "logit") {
IRF     <- plogis( W )
} else if (irf == "sirm") {
IRF     <- 1 / (1 + exp(W))
} else { stop("Unkown IRF :(") }
} else { stop("Unkown basis :(") }
LL      <- sum( dbinom(Data$X[,3], size=(Data$levels - 1), prob=IRF, log=T) )
### Log-Posterior
LP <- LL + Lpp
### Estimates
yhat <- rbinom(length(IRF), size=(Data$levels - 1), prob=IRF)
### Output
Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=yhat, parm=parm)
return(Modelout)
}
Model <- compiler::cmpfun(Model)
Initial.Values <- GIV(Model, MyData, PGF=T)
is.model(Model, Initial.Values, MyData)
is.bayesian(Model, Initial.Values, MyData)
Fit <- MAP(Model=Model, parm=Initial.Values, Data=MyData,
maxit=Iters, temp=temp, tmax=tmax, REPORT=Status)
abil = Fit$parm[pos.theta]
diff = Fit$parm[pos.b]
rownames(Base) = colnames(x)
colnames(Base) = paste("Beta",1:len_basis,sep="_")
Base = Fit$parm[pos.b]
rownames(Base) = colnames(x)
abil = Fit$parm[pos.theta]
Base = Fit$parm[pos.b]
Base
Base = matrix(Fit$parm[pos.b], nrow=ncol(x))
rownames(Base) = colnames(x)
colnames(Base) = paste("Beta",1:len_basis,sep="_")
Base
ICC <- lapply(1:nrow(Base), function(g) {
Pr <- plogis(
as.vector(crossprod(Base[g,],
t((((plogis(seq(-3,3,len=100)) <
t(matrix(knots, nrow=len_basis, ncol=100))) * -2) +1)) )))
theta <- seq(-3,3,len=100)
return(data.frame(theta, Pr))
})
ICC
plot(ICC[[1]])
plot(ICC[[2]])
plot(ICC[[3]])
plot(ICC[[4]])
plot(ICC[[5]])
plot(ICC[[6]])
plot(ICC[[7]])
plot(ICC[[8]])
plot(ICC[[9]])
plot(ICC[[10]])
abil
plot(abil ~ data$abil)
rm(list=ls())
dev.off()
