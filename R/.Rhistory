OPT_Res <- BayesianOptimization(LogPost,
bounds = list(para = c(-3, 3)),
init_points = 5, n_iter = 20,
acq = "poi", eps = 0.1,
verbose = TRUE)
suppressMessages(require(emoptim))
install.packages("remotes")
remotes::install_github("ehsan66/emoptim")
remotes::install_github("ehsan66/emoptim")
require(remotes)
remotes::install_github("ehsan66/emoptim")
suppressMessages(require(emoptim))
repeats <- 1:length(Data$parm.names
repeats <- 1:length(Data$parm.names)
repeats <- c(1:length(Data$parm.names))
LogPost <- function(para) {
LP <- Model(para[1:repeats], Data)
list(Score = LP$LP, Pred = 0)
}
emoptim::ncde(fn=LogPost, lower=rep(-3,repeats), upper=rep(3,repeats),
control=list(seed=666, NP=100, hybrid=T))
rep(-3,repeats)
repeats
emoptim::ncde(fn=LogPost, lower=rep(-3,max(repeats)), upper=rep(3,max(repeats)),
control=list(seed=666, NP=100, hybrid=T))
?ncde
repeats <- c(1:length(Data$parm.names))
LogPost <- function(para) {
LP <- Model(para[1:repeats], Data)
-LP$LP
}
emoptim::ncde(fn=LogPost, lower=rep(-3,max(repeats)), upper=rep(3,max(repeats)),
control=list(iter=200, seed=666, NP=100, hybrid=T))
para[1:repeats]
rm(para)
repeats <- c(1:length(Data$parm.names))
LogPost <- function(para) {
LP <- Model(para[1:repeats], Data)
-LP$LP
}
emoptim::ncde(fn=LogPost, lower=rep(-3,max(repeats)), upper=rep(3,max(repeats)),
control=list(iter=200, seed=666, NP=100, hybrid=T))
repeats <- c(1:length(Data$parm.names))
LogPost <- function(par) {
LP <- Model(par[1:repeats], Data)
-LP$LP
}
emoptim::ncde(fn=LogPost, lower=rep(-3,max(repeats)), upper=rep(3,max(repeats)),
control=list(iter=200, seed=666, NP=100, hybrid=T))
repeats <- c(1:length(Data$parm.names))
LogPost <- function(par) {
LogPost <- Model(par[1:repeats], Data)
-LogPost$LP
}
emoptim::ncde(fn=LogPost, lower=rep(-3,max(repeats)), upper=rep(3,max(repeats)),
control=list(iter=200, seed=666, NP=100, hybrid=T))
repeats <- c(1:length(Data$parm.names))
LogPost <- function(par) {
LogPost <- Model(par[repeats], Data)
-LogPost$LP
}
emoptim::ncde(fn=LogPost, lower=rep(-3,max(repeats)), upper=rep(3,max(repeats)),
control=list(iter=200, seed=666, NP=100, hybrid=T))
repets
repeats
repeats <- c(1:length(Data$parm.names))
LogPost <- function(par) {
LogPost <- Model(par[repeats], Data)
LogPost$LP
}
emoptim::ncde(fn=LogPost, lower=rep(-3,max(repeats)), upper=rep(3,max(repeats)),
control=list(iter=200, seed=666, NP=100, hybrid=T))
Sys.sleep(.25)
repeats <- c(1:length(Data$parm.names))
LogPost <- function(par) {
LogPost <- Model(par[repeats], Data)
LogPost$LP
}
emoptim::ncde(fn=LogPost, lower=rep(-3,max(repeats)), upper=rep(3,max(repeats)),
control=list(iter=200, SF=.2, seed=666, hybrid=T))
par <- rnorm(max(repeats))
LogPost <- Model(par[repeats], Data)
LogPost$LP
emoptim::ncde(fn=LogPost, #lower=rep(-3,max(repeats)), upper=rep(3,max(repeats)),
control=list(iter=200, SF=.2, seed=666, hybrid=T))
repeats <- c(1:length(Data$parm.names))
LogPost <- function(par) {
LogPost <- Model(par[repeats], Data)
LogPost$LP
}
emoptim::ncde(fn=LogPost, lower=rep(-3,max(repeats)), upper=rep(3,max(repeats)),
control=list(iter=200, SF=.2, seed=666, hybrid=T))
X <- rnorm(100)
Y <- .3 * X + (rnorm(100) * sqrt(1 - (.3^2)))
fun <- function(par) -(par * X - Y)
emoptim::ncde(fn=fun, lower=-3, upper=3,
control=list(iter=200, SF=.2, seed=666, hybrid=T))
emoptim::ncde(fn=fun, lower=0, upper=2,
control=list(iter=200, SF=.2, seed=666, hybrid=T))
emoptim::ncde(fn=fun, lower=0, upper=1,
control=list(iter=200, SF=.2, seed=666, hybrid=T))
emoptim::ncde(fn=fun, lower=1e-5, upper=1,
control=list(iter=200, SF=.2, seed=666, hybrid=T))
fun(1)
fun <- function(par) -sum(par * X - Y)
emoptim::ncde(fn=fun, lower=1e-5, upper=1,
control=list(iter=200, SF=.2, seed=666, hybrid=T))
fun(.3)
fun(.1)
fun(.2)
fun(.3)
fun(.7)
fun(.8)
fun(.9)
fun(1)
fun <- function(par) -sum(abs(par * X - Y))
emoptim::ncde(fn=fun, lower=1e-5, upper=1,
control=list(iter=200, SF=.2, seed=666, hybrid=T))
cor(X,Y)
fun <- function(par) -sqrt(sum((par * X - Y)^2))
emoptim::ncde(fn=fun, lower=1e-5, upper=1,
control=list(iter=200, SF=.2, seed=666, hybrid=T))
repeats <- c(1:length(Data$parm.names))
LogPost <- function(para) {
LP <- Model(para[1:repeats], Data)
LP$LP
}
emoptim::ncde(fn=LogPost, lower=rep(-3,max(repeats)), upper=rep(3,max(repeats)),
control=list(iter=200, seed=666, NP=100, hybrid=T))
repeats <- max(1:length(Data$parm.names))
LogPost <- function(para) {
LP <- Model(para[1:length(Data$parm.names)], Data)
LP$LP
}
emoptim::ncde(fn=LogPost, lower=rep(-3,repeats), upper=rep(3,repeats),
control=list(iter=200, seed=666, NP=100, hybrid=T))
repeats <- max(1:length(Data$parm.names))
LogPost <- function(para) {
LP <- Model(para[1:length(Data$parm.names)], Data)
LP$LP
}
emoptim::ncde(fn=LogPost, lower=rep(-3,repeats), upper=rep(3,repeats),
control=list(iter=200, seed=666, NP=100, hybrid=T))
rep(-3,repeats)
rep(3,repeats)
emoptim::ncde(fn=LogPost, lower=rep(-6,repeats), upper=rep(6,repeats),
control=list(iter=200, seed=666, NP=100, hybrid=T))
repeats <- max(1:length(Data$parm.names))
LogPost <- function(para, Model, Data) {
LP <- Model(para[1:length(Data$parm.names)], Data)
LP$LP
}
emoptim::ncde(fn=LogPost, lower=rep(-3,repeats), upper=rep(3,repeats),
control=list(iter=200, seed=666, NP=100, hybrid=T))
repeats <- max(1:length(Data$parm.names))
LogPost <- function(para, Model, Data) {
LP <- Model(para[1:length(Data$parm.names)], Data)
-LP$LP
}
emoptim::ncde(fn=LogPost, lower=rep(-3,repeats), upper=rep(3,repeats),
control=list(iter=200, seed=666, NP=100, hybrid=T))
suppressMessages(require(GA))
install.packages("GA")
?ga
suppressMessages(require(GA))
?ga
LogPost <- function(para, Model, Data) {
LP <- Model(para[1:length(Data$parm.names)], Data)
LP$LP
}
estimates <- ga("binary", fitness = LogPost, nBits = ncol(x),
names=colnames(x), monitor=plot)
LogPost <- function(para) {
LP <- Model(para[1:length(Data$parm.names)], Data)
LP$LP
}
estimates <- ga("binary", fitness = LogPost, nBits = ncol(x),
names=colnames(x), monitor=plot)
estimates <- ga("real_valued", fitness = LogPost, nBits = ncol(x),
names=colnames(x), monitor=plot)
estimates <- ga("real-valued", fitness = LogPost, nBits = ncol(x),
names=colnames(x), monitor=plot)
estimates <- ga("real-valued", fitness = LogPost,
lower=c(-3,length(Data$parm.names)),
upper=c(3,length(Data$parm.names))
names=colnames(x), monitor=plot)
estimates <- ga("real-valued", fitness = LogPost,
lower=rep(-3,length(Data$parm.names)),
upper=rep(3,length(Data$parm.names))
names=colnames(x), monitor=plot)
estimates <- ga("real-valued", fitness = LogPost,
lower=rep(-3,length(Data$parm.names)),
upper=rep(3,length(Data$parm.names)),
names=colnames(x), monitor=plot)
parm.names
estimates <- ga("real-valued", fitness = LogPost,
lower=rep(-3,length(Data$parm.names)),
upper=rep(3,length(Data$parm.names)),
names=Data$parm.names, monitor=plot)
estimates
summary(estimates)
unlist(estimates)
estimates@solution
Model(estimates@solution, Data)
LogPost <- function(para) {
LP <- Model(para[1:length(Data$parm.names)], Data)
LP$LP
}
estimates <- ga("real-valued", fitness = LogPost,
lower=rep(-3,length(Data$parm.names)),
upper=rep(3,length(Data$parm.names)),
names=Data$parm.names, monitor=plot)
Model(estimates@solution, Data)
LogPost <- function(para) {
LP <- Model(para[1:length(Data$parm.names)], Data)
LP$LP
}
estimates <- ga("real-valued", fitness = LogPost,
lower=rep(-3,length(Data$parm.names)),
upper=rep(3,length(Data$parm.names)),
names=Data$parm.names, monitor=T)
Model(estimates@solution, Data)
data <- birm::simData(30,5,sequence=TRUE)
x <- data$data
### Start====
require(LaplacesDemon)
require(compiler)
require(parallel)
require(tidyr)
CPUs = detectCores(all.tests = FALSE, logical = TRUE) - 1
if(CPUs == 0) CPUs = 1
### Convert data to long format====
lonlong <- gather(data.frame(x), item, resp, colnames(x), factor_key=TRUE)
data_long <- data.frame(ID=rep(1:nrow(x), times=ncol(x)),lonlong)
### Choose a model====
if (interaction == F) {
### Rasch model
# Assemble data list
if (method == "MAP") {
mon.names  <- "LL"
} else { mon.names  <- "LP" }
parm.names <- as.parm.names(list( theta=rep(0,nrow(x)), b=rep(0,ncol(x)) ))
pos.theta  <- grep("theta", parm.names)
pos.b      <- grep("b", parm.names)
PGF <- function(Data) {
theta <- rnorm(Data$n)
b     <- rnorm(Data$v)
return(c(theta, b))
}
MyData <- list(parm.names=parm.names, mon.names=mon.names,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x),
pos.theta=pos.theta, pos.b=pos.b)
is.data(MyData)
# Model
Model <- function(parm, Data){
## Prior parameters
theta <- parm[Data$pos.theta]
b     <- parm[Data$pos.b]
### Log-Priors
theta.prior <- sum(dnorm(theta, mean=0, sd=1, log=TRUE))
b.prior     <- sum(dnorm(b, mean=0, sd=1, log=T))
Lpp <- theta.prior + b.prior
### Log-Likelihood
thetaLL <- rep(theta, times=Data$v)
bLL     <- rep(b    , each=Data$n)
IRF     <- plogis( thetaLL - bLL )
LL      <- sum( dbinom(Data$X[,3], size=1, prob=IRF, log=T) )
### Log-Posterior
LP <- LL + Lpp
### Estimates
yhat <- rbinom(length(IRF), size=1, prob=IRF)
### Output
Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=yhat, parm=parm)
return(Modelout)
}
Model <- compiler::cmpfun(Model)
Initial.Values <- GIV(Model, MyData, PGF=T)
is.model(Model, Initial.Values, MyData)
is.bayesian(Model, Initial.Values, MyData)
} else if (interaction == T) {
### Rasch Interaction model
# Assemble data list
mon.names  <- "LP"
parm.names <- as.parm.names(list( theta=rep(0,nrow(x)),
b=rep(0,ncol(x)),
delta=rep(0,1) ))
pos.theta  <- grep("theta", parm.names)
pos.b      <- grep("b", parm.names)
pos.delta  <- grep("delta", parm.names)
PGF <- function(Data) {
theta <- rnorm(Data$n)
b     <- rnorm(Data$v)
delta <- rnorm(1, 0, 1)
return(c(theta, b, delta))
}
MyData <- list(parm.names=parm.names, mon.names=mon.names,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x),
pos.theta=pos.theta, pos.b=pos.b, pos.delta=pos.delta)
is.data(MyData)
# Model
Model <- function(parm, Data){
## Prior parameters
theta <- parm[Data$pos.theta]
b     <- parm[Data$pos.b]
delta <- parm[Data$pos.delta]
### Log-Priors
theta.prior <- sum(dnorm(theta, mean=0, sd=1, log=T))
b.prior     <- sum(dnorm(b, mean=0, sd=1, log=T))
delta.prior <- sum(dnorm(delta, mean=0, sd=1, log=T))
Lpp <- theta.prior + b.prior + delta.prior
### Log-Likelihood
thetaLL <- rep(theta, times=Data$v)
bLL     <- rep(b    , each=Data$n)
deltaLL <- rep(delta, each=Data$n * Data$v)
IRF     <- plogis( thetaLL + bLL + (deltaLL * thetaLL * bLL) )
LL      <- sum( dbinom(Data$X[,3], size=1, prob=IRF, log=T) )
### Log-Posterior
LP <- LL + Lpp
### Estimates
yhat <- rbinom(length(IRF), size=1, prob=IRF)
### Output
Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=yhat, parm=parm)
return(Modelout)
}
Model <- compiler::cmpfun(Model)
Initial.Values <- GIV(Model, MyData, PGF=T)
is.model(Model, Initial.Values, MyData)
is.bayesian(Model, Initial.Values, MyData)
} else stop("Unknow model :(")
LogPost <- function(para) {
LP <- Model(para[1:length(Data$parm.names)], Data)
LP$LP
}
estimates <- ga("real-valued", fitness = LogPost,
lower=rep(-3,length(Data$parm.names)),
upper=rep(3,length(Data$parm.names)),
names=Data$parm.names, monitor=T)
Model(estimates@solution, Data)
Data <- MyData
LogPost <- function(para) {
LP <- Model(para[1:length(Data$parm.names)], Data)
LP$LP
}
estimates <- ga("real-valued", fitness = LogPost,
lower=rep(-3,length(Data$parm.names)),
upper=rep(3,length(Data$parm.names)),
names=Data$parm.names, monitor=T)
Model(estimates@solution, Data)
plot(data$abil, Model(estimates@solution, Data)$parm[1:30])
cor(data$abil, Model(estimates@solution, Data)$parm[1:30])
LogPost <- function(para) {
LP <- Model(para[1:length(Data$parm.names)], Data)
LP$LP
}
estimates <- ga("real-valued", fitness = LogPost,
lower=rep(-5,length(Data$parm.names)),
upper=rep(5,length(Data$parm.names)),
names=Data$parm.names, monitor=T)
Model(estimates@solution, Data)
LogPost <- function(para) {
LP <- Model(para[1:length(Data$parm.names)], Data)
-LP$LP
}
estimates <- ga("real-valued", fitness = LogPost,
lower=rep(-5,length(Data$parm.names)),
upper=rep(5,length(Data$parm.names)),
names=Data$parm.names, monitor=T)
Model(estimates@solution, Data)
plot(data$abil, Model(estimates@solution, Data)$parm[1:30])
cor(data$abil, Model(estimates@solution, Data)$parm[1:30])
LogPost <- function(para) {
LP <- Model(para[1:length(Data$parm.names)], Data)
LP$LP
}
estimates <- ga("real-valued", fitness = LogPost,
lower=rep(-5,length(Data$parm.names)),
upper=rep(5,length(Data$parm.names)),
names=Data$parm.names, monitor=T)
cor(data$abil, Model(estimates@solution, Data)$parm[1:30])
plot(data$abil, Model(estimates@solution, Data)$parm[1:30])
eestimates
estimates
summary(estimates)
install.packages("FME")
suppressMessages(require(FME))
Sys.sleep(.25)
LogPost <- function(para) {
LP <- Model(para[1:length(Data$parm.names)], Data)
-LP$LP
}
estimates <- FME::modFit(f = LogPost, p = rep(0, length(Data$parm.names)))
interaction=F; method="VB"
data <- birm::simData(30,5,sequence=T)
x <- data$data
### Start====
require(LaplacesDemon)
require(compiler)
require(parallel)
require(tidyr)
CPUs = detectCores(all.tests = FALSE, logical = TRUE) - 1
if(CPUs == 0) CPUs = 1
### Convert data to long format====
lonlong <- gather(data.frame(x), item, resp, colnames(x), factor_key=TRUE)
data_long <- data.frame(ID=rep(1:nrow(x), times=ncol(x)),lonlong)
### Choose a model====
if (interaction == F) {
### Rasch model
# Assemble data list
if (method == "MAP") {
mon.names  <- "LL"
} else { mon.names  <- "LP" }
parm.names <- as.parm.names(list( theta=rep(0,nrow(x)), b=rep(0,ncol(x)) ))
pos.theta  <- grep("theta", parm.names)
pos.b      <- grep("b", parm.names)
PGF <- function(Data) {
theta <- rnorm(Data$n)
b     <- rnorm(Data$v)
return(c(theta, b))
}
MyData <- list(parm.names=parm.names, mon.names=mon.names,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x),
pos.theta=pos.theta, pos.b=pos.b)
is.data(MyData)
# Model
Model <- function(parm, Data){
## Prior parameters
theta <- parm[Data$pos.theta]
b     <- parm[Data$pos.b]
### Log-Priors
theta.prior <- sum(dnorm(theta, mean=0, sd=1, log=TRUE))
b.prior     <- sum(dnorm(b, mean=0, sd=1, log=T))
Lpp <- theta.prior + b.prior
### Log-Likelihood
thetaLL <- rep(theta, times=Data$v)
bLL     <- rep(b    , each=Data$n)
IRF     <- plogis( thetaLL - bLL )
LL      <- sum( dbinom(Data$X[,3], size=1, prob=IRF, log=T) )
### Log-Posterior
LP <- LL + Lpp
### Estimates
yhat <- rbinom(length(IRF), size=1, prob=IRF)
### Output
Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=yhat, parm=parm)
return(Modelout)
}
Model <- compiler::cmpfun(Model)
Initial.Values <- GIV(Model, MyData, PGF=T)
is.model(Model, Initial.Values, MyData)
is.bayesian(Model, Initial.Values, MyData)
} else if (interaction == T) {
### Rasch Interaction model
# Assemble data list
mon.names  <- "LP"
parm.names <- as.parm.names(list( theta=rep(0,nrow(x)),
b=rep(0,ncol(x)),
delta=rep(0,1) ))
pos.theta  <- grep("theta", parm.names)
pos.b      <- grep("b", parm.names)
pos.delta  <- grep("delta", parm.names)
PGF <- function(Data) {
theta <- rnorm(Data$n)
b     <- rnorm(Data$v)
delta <- rnorm(1, 0, 1)
return(c(theta, b, delta))
}
MyData <- list(parm.names=parm.names, mon.names=mon.names,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x),
pos.theta=pos.theta, pos.b=pos.b, pos.delta=pos.delta)
is.data(MyData)
# Model
Model <- function(parm, Data){
## Prior parameters
theta <- parm[Data$pos.theta]
b     <- parm[Data$pos.b]
delta <- parm[Data$pos.delta]
### Log-Priors
theta.prior <- sum(dnorm(theta, mean=0, sd=1, log=T))
b.prior     <- sum(dnorm(b, mean=0, sd=1, log=T))
delta.prior <- sum(dnorm(delta, mean=0, sd=1, log=T))
Lpp <- theta.prior + b.prior + delta.prior
### Log-Likelihood
thetaLL <- rep(theta, times=Data$v)
bLL     <- rep(b    , each=Data$n)
deltaLL <- rep(delta, each=Data$n * Data$v)
IRF     <- plogis( thetaLL + bLL + (deltaLL * thetaLL * bLL) )
LL      <- sum( dbinom(Data$X[,3], size=1, prob=IRF, log=T) )
### Log-Posterior
LP <- LL + Lpp
### Estimates
yhat <- rbinom(length(IRF), size=1, prob=IRF)
### Output
Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=yhat, parm=parm)
return(Modelout)
}
Model <- compiler::cmpfun(Model)
Initial.Values <- GIV(Model, MyData, PGF=T)
is.model(Model, Initial.Values, MyData)
is.bayesian(Model, Initial.Values, MyData)
} else stop("Unknow model :(")
Data <- MyData
LogPost <- function(para) {
LP <- Model(para[1:length(Data$parm.names)], Data)
-LP$LP
}
estimates <- FME::modFit(f = LogPost, p = rep(0, length(Data$parm.names)))
source("GA.R")
GA(Model, Initial.Values, Data)
parm = Initial.Values
estimates <- FME::modFit(f = LogPost, p = parm)
rm(list=ls())
?ga
?GA::ga
