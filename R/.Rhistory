require(compiler)
require(parallel)
require(tidyr)
CPUs = detectCores(all.tests = FALSE, logical = TRUE) - 1
if(CPUs == 0) CPUs = 1
### Convert data to long format====
lonlong <- gather(data.frame(x), item, resp, colnames(x), factor_key=TRUE)
data_long <- data.frame(ID=rep(1:nrow(x), times=ncol(x)),lonlong)
### Choose a model====
# Assemble data list
if (method == "MAP") {
mon.names  <- "LL"
} else { mon.names  <- "LP" }
dep = (ncol(x) * (ncol(x) - 1))/2
z   = function(x) .5 * log((1 + x)/(1 - x))
vec2mat = function(x, rows, cols) {
myvec <- x
mycor <- matrix(0,rows,cols)
mycor[ col(mycor) < row(mycor) ] <- myvec
mycor <- mycor + t(mycor)
diag(mycor) <- 1
mycor
}
obs.cor <- mixedCor(x)$rho
ega <- EGAnet::EGA(obs.cor, n=nrow(x), plot=F)$wc
ob.cor  <- z(obs.cor[lower.tri(obs.cor)])
rz   = function(x) (exp(2*x) - 1) / (exp(2*x) + 1)
parm.names <- as.parm.names(list( rho=rep(0,dep), sigma=rep(0,dep) ))
pos.rho    <- grep("rho", parm.names)
pos.sigma  <- grep("sigma", parm.names)
PGF <- function(Data) {
rho   <- rnorm(Data$dep)
sigma <- rnorm(Data$dep)
return(c(rho, sigma))
}
MyData <- list(parm.names=parm.names, mon.names=mon.names,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x),
dep=dep, ob.cor=ob.cor, pos.rho=pos.rho,
pos.sigma=pos.sigma, ega=ega, rz=rz, vec2mat=vec2mat)
is.data(MyData)
# Model
Model <- function(parm, Data){
## Prior parameters
rho   <- parm[Data$pos.rho]
sigma <- parm[Data$pos.sigma]
### Log-Priors
rho.prior   <- sum( dnorm(rho, mean=0, sd=1, log=TRUE) )
sigma.prior <- sum( dgamma(exp(sigma), shape=1e-2, shape=1e-2, log=TRUE) )
Lpp <- rho.prior + sigma.prior
### Log-Likelihood
ega    <- EGAnet::EGA(Data$vec2mat(Data$rz(rho),Data$v,Data$v), n=Data$n, plot=F)$wc
LL.cor <- sum( dnorm(Data$ob.cor, mean=rho, sd=exp(sigma), log=TRUE) )
LL <- LL.cor
### Log-Posterior
LP <- LL + Lpp
### Estimates
yhat <- rbinom(length(IRF), size=1, prob=IRF)
### Output
Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=yhat, parm=parm)
return(Modelout)
}
Model <- compiler::cmpfun(Model)
Initial.Values <- GIV(Model, MyData, PGF=T)
is.model(Model, Initial.Values, MyData)
is.bayesian(Model, Initial.Values, MyData)
# Assemble data list====
if (method == "MAP") {
mon.names  <- "LL"
} else { mon.names  <- "LP" }
dep = (ncol(x) * (ncol(x) - 1))/2
z   = function(x) .5 * log((1 + x)/(1 - x))
vec2mat = function(x, rows, cols) {
myvec <- x
mycor <- matrix(0,rows,cols)
mycor[ col(mycor) < row(mycor) ] <- myvec
mycor <- mycor + t(mycor)
diag(mycor) <- 1
mycor
}
obs.cor <- mixedCor(x)$rho
ega <- EGAnet::EGA(obs.cor, n=nrow(x), plot=F)$wc
ob.cor  <- z(obs.cor[lower.tri(obs.cor)])
rz   = function(x) (exp(2*x) - 1) / (exp(2*x) + 1)
parm.names <- as.parm.names(list( rho=rep(0,dep), sigma=rep(0,dep) ))
pos.rho    <- grep("rho", parm.names)
pos.sigma  <- grep("sigma", parm.names)
PGF <- function(Data) {
rho   <- rnorm(Data$dep)
sigma <- rnorm(Data$dep)
return(c(rho, sigma))
}
MyData <- list(parm.names=parm.names, mon.names=mon.names,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x),
dep=dep, ob.cor=ob.cor, pos.rho=pos.rho,
pos.sigma=pos.sigma, ega=ega, rz=rz, vec2mat=vec2mat)
is.data(MyData)
Data <- MyData
## Prior parameters
rho   <- parm[Data$pos.rho]
rho
sigma
sigma <- rnorm(Data$dep)
### Log-Priors
rho.prior   <- sum( dnorm(rho, mean=0, sd=1, log=TRUE) )
sigma.prior <- sum( dgamma(exp(sigma), shape=1e-2, shape=1e-2, log=TRUE) )
sigma.prior <- sum( dgamma(exp(sigma), shape=1e-2, rate=1e-2, log=TRUE) )
Lpp <- rho.prior + sigma.prior
Lpp
### Log-Likelihood
ega    <- EGAnet::EGA(Data$vec2mat(Data$rz(rho),Data$v,Data$v), n=Data$n, plot=F)$wc
Data$vec2mat(Data$rz(rho),Data$v,Data$v)
MyData <- list(parm.names=parm.names, mon.names=mon.names,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x),
dep=dep, ob.cor=ob.cor, pos.rho=pos.rho, v.names=colnames(x),
pos.sigma=pos.sigma, ega=ega, rz=rz, vec2mat=vec2mat)
Data <- MyData
Data
colnames(CORR) <- rownames(CORR) <- Data$v.names
### Log-Likelihood
CORR   <- Data$vec2mat(Data$rz(rho),Data$v,Data$v)
colnames(CORR) <- rownames(CORR) <- Data$v.names
CORR
ega    <- EGAnet::EGA(CORR, n=Data$n, plot=F)$wc
e.ega    <- EGAnet::EGA(CORR, n=Data$n, plot=F)$wc
e.ega
ega <- EGAnet::EGA(obs.cor, n=nrow(x), plot=F)$wc
e.ega
ega
dcat(ega, e.ega)
dbinom((ega - 1), 4, prob=.5)
### Start====
require(LaplacesDemon)
require(compiler)
require(parallel)
require(tidyr)
CPUs = detectCores(all.tests = FALSE, logical = TRUE) - 1
if(CPUs == 0) CPUs = 1
### Convert data to long format====
lonlong <- gather(data.frame(x), item, resp, colnames(x), factor_key=TRUE)
data_long <- data.frame(ID=rep(1:nrow(x), times=ncol(x)),lonlong)
# Assemble data list====
if (method == "MAP") {
mon.names  <- "LL"
} else { mon.names  <- "LP" }
dep = (ncol(x) * (ncol(x) - 1))/2
z   = function(x) .5 * log((1 + x)/(1 - x))
vec2mat = function(x, rows, cols) {
myvec <- x
mycor <- matrix(0,rows,cols)
mycor[ col(mycor) < row(mycor) ] <- myvec
mycor <- mycor + t(mycor)
diag(mycor) <- 1
mycor
}
obs.cor <- mixedCor(x)$rho
ega <- EGAnet::EGA(obs.cor, n=nrow(x), plot=F)$wc
ob.cor  <- z(obs.cor[lower.tri(obs.cor)])
rz   = function(x) (exp(2*x) - 1) / (exp(2*x) + 1)
parm.names <- as.parm.names(list( rho=rep(0,dep), sigma=rep(0,dep) ))
pos.rho    <- grep("rho", parm.names)
pos.sigma  <- grep("sigma", parm.names)
PGF <- function(Data) {
rho   <- rnorm(Data$dep)
sigma <- rnorm(Data$dep)
return(c(rho, sigma))
}
MyData <- list(parm.names=parm.names, mon.names=mon.names,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x),
dep=dep, ob.cor=ob.cor, pos.rho=pos.rho, v.names=colnames(x),
pos.sigma=pos.sigma, ega=ega, rz=rz, vec2mat=vec2mat)
is.data(MyData)
# Model====
Model <- function(parm, Data){
## Prior parameters
rho   <- parm[Data$pos.rho]
sigma <- parm[Data$pos.sigma]
### Log-Priors
rho.prior   <- sum( dnorm(rho, mean=0, sd=1, log=TRUE) )
sigma.prior <- sum( dgamma(exp(sigma), shape=1e-2, rate=1e-2, log=TRUE) )
Lpp <- rho.prior + sigma.prior
### Log-Likelihood
CORR   <- Data$vec2mat(Data$rz(rho),Data$v,Data$v)
colnames(CORR) <- rownames(CORR) <- Data$v.names
e.ega  <- EGAnet::EGA(CORR, n=Data$n, plot=F)$wc
LL.ega <- sum( dnorm((e.ega - ega), mean=0, sd=1, log=TRUE) )
LL.cor <- sum( dnorm(Data$ob.cor, mean=rho, sd=exp(sigma), log=TRUE) )
LL <- LL.cor + LL.ega
### Log-Posterior
LP <- LL + Lpp
### Estimates
yhat <- rbinom(length(IRF), size=1, prob=IRF)
### Output
Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=yhat, parm=parm)
return(Modelout)
}
Model <- compiler::cmpfun(Model)
Initial.Values <- GIV(Model, MyData, PGF=T)
is.model(Model, Initial.Values, MyData)
is.bayesian(Model, Initial.Values, MyData)
### Start====
require(LaplacesDemon)
require(compiler)
require(parallel)
require(tidyr)
CPUs = detectCores(all.tests = FALSE, logical = TRUE) - 1
if(CPUs == 0) CPUs = 1
### Convert data to long format====
lonlong <- gather(data.frame(x), item, resp, colnames(x), factor_key=TRUE)
data_long <- data.frame(ID=rep(1:nrow(x), times=ncol(x)),lonlong)
# Assemble data list====
if (method == "MAP") {
mon.names  <- "LL"
} else { mon.names  <- "LP" }
dep = (ncol(x) * (ncol(x) - 1))/2
z   = function(x) .5 * log((1 + x)/(1 - x))
vec2mat = function(x, rows, cols) {
myvec <- x
mycor <- matrix(0,rows,cols)
mycor[ col(mycor) < row(mycor) ] <- myvec
mycor <- mycor + t(mycor)
diag(mycor) <- 1
mycor
}
obs.cor <- mixedCor(x)$rho
ega <- EGAnet::EGA(obs.cor, n=nrow(x), plot=F)$wc
ob.cor  <- z(obs.cor[lower.tri(obs.cor)])
rz   = function(x) (exp(2*x) - 1) / (exp(2*x) + 1)
parm.names <- as.parm.names(list( rho=rep(0,dep), sigma=rep(0,dep) ))
pos.rho    <- grep("rho", parm.names)
pos.sigma  <- grep("sigma", parm.names)
PGF <- function(Data) {
rho   <- rnorm(Data$dep)
sigma <- rnorm(Data$dep)
return(c(rho, sigma))
}
MyData <- list(parm.names=parm.names, mon.names=mon.names,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x),
dep=dep, ob.cor=ob.cor, pos.rho=pos.rho, v.names=colnames(x),
pos.sigma=pos.sigma, ega=ega, rz=rz, vec2mat=vec2mat)
is.data(MyData)
# Model====
Model <- function(parm, Data){
## Prior parameters
rho   <- parm[Data$pos.rho]
sigma <- parm[Data$pos.sigma]
### Log-Priors
rho.prior   <- sum( dnorm(rho, mean=0, sd=1, log=TRUE) )
sigma.prior <- sum( dgamma(exp(sigma), shape=1e-2, rate=1e-2, log=TRUE) )
Lpp <- rho.prior + sigma.prior
### Log-Likelihood
CORR   <- Data$vec2mat(Data$rz(rho),Data$v,Data$v)
colnames(CORR) <- rownames(CORR) <- Data$v.names
e.ega  <- EGAnet::EGA(CORR, n=Data$n, plot=F)$wc
LL.ega <- sum( dnorm((e.ega - ega), mean=0, sd=1, log=TRUE) )
LL.cor <- sum( dnorm(Data$ob.cor, mean=rho, sd=exp(sigma), log=TRUE) )
LL <- LL.cor + LL.ega
### Log-Posterior
LP <- LL + Lpp
### Estimates
yhat <- rbinom(length(IRF), size=1, prob=IRF)
### Output
Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=yhat, parm=parm)
return(Modelout)
}
Model <- compiler::cmpfun(Model)
Initial.Values <- GIV(Model, MyData, PGF=T)
GIV
LIV <- length(Data[["parm.names"]])
iv <- rep(NA, LIV)
iv
LIV
IV <- as.vector(Data$PGF(Data))
M <- try(Model(IV, Data), silent = TRUE)
M
### Convert data to long format====
lonlong <- gather(data.frame(x), item, resp, colnames(x), factor_key=TRUE)
data_long <- data.frame(ID=rep(1:nrow(x), times=ncol(x)),lonlong)
# Assemble data list====
if (method == "MAP") {
mon.names  <- "LL"
} else { mon.names  <- "LP" }
dep = (ncol(x) * (ncol(x) - 1))/2
z   = function(x) .5 * log((1 + x)/(1 - x))
vec2mat = function(x, rows, cols) {
myvec <- x
mycor <- matrix(0,rows,cols)
mycor[ col(mycor) < row(mycor) ] <- myvec
mycor <- mycor + t(mycor)
diag(mycor) <- 1
mycor
}
obs.cor <- mixedCor(x)$rho
ega <- EGAnet::EGA(obs.cor, n=nrow(x), plot=F)$wc
ob.cor  <- z(obs.cor[lower.tri(obs.cor)])
rz   = function(x) (exp(2*x) - 1) / (exp(2*x) + 1)
parm.names <- as.parm.names(list( rho=rep(0,dep), sigma=rep(0,dep) ))
pos.rho    <- grep("rho", parm.names)
pos.sigma  <- grep("sigma", parm.names)
PGF <- function(Data) {
rho   <- rnorm(Data$dep)
sigma <- rnorm(Data$dep)
return(c(rho, sigma))
}
MyData <- list(parm.names=parm.names, mon.names=mon.names,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x), z=z,
dep=dep, ob.cor=ob.cor, pos.rho=pos.rho, v.names=colnames(x),
pos.sigma=pos.sigma, ega=ega, rz=rz, vec2mat=vec2mat)
is.data(MyData)
# Model====
Model <- function(parm, Data){
## Prior parameters
rho   <- parm[Data$pos.rho]
sigma <- parm[Data$pos.sigma]
### Log-Priors
rho.prior   <- sum( dnorm(rho, mean=0, sd=1, log=TRUE) )
sigma.prior <- sum( dgamma(exp(sigma), shape=1e-2, rate=1e-2, log=TRUE) )
Lpp <- rho.prior + sigma.prior
### Log-Likelihood
CORR   <- Data$vec2mat(Data$rz(rho),Data$v,Data$v)
colnames(CORR) <- rownames(CORR) <- Data$v.names
e.ega  <- EGAnet::EGA(CORR, n=Data$n, plot=F)$wc
LL.ega <- sum( dnorm((e.ega - ega), mean=0, sd=1, log=TRUE) )
LL.cor <- sum( dnorm(Data$ob.cor, mean=rho, sd=exp(sigma), log=TRUE) )
LL <- LL.cor + LL.ega
### Log-Posterior
LP <- LL + Lpp
### Estimates
yhat <- Data$z(rnorm(length(rho), mean=rho, sd=exp(sigma)))
### Output
Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=yhat, parm=parm)
return(Modelout)
}
Model <- compiler::cmpfun(Model)
Initial.Values <- GIV(Model, MyData, PGF=T)
is.model(Model, Initial.Values, MyData)
is.bayesian(Model, Initial.Values, MyData)
Model <- function(parm, Data){
## Prior parameters
rho   <- parm[Data$pos.rho]
sigma <- parm[Data$pos.sigma]
### Log-Priors
rho.prior   <- sum( dnorm(rho, mean=0, sd=1, log=TRUE) )
sigma.prior <- sum( dgamma(exp(sigma), shape=1e-2, rate=1e-2, log=TRUE) )
Lpp <- rho.prior + sigma.prior
### Log-Likelihood
CORR   <- Data$vec2mat(Data$rz(rho),Data$v,Data$v)
colnames(CORR) <- rownames(CORR) <- Data$v.names
e.ega  <- suppressMessages( EGAnet::EGA(CORR, n=Data$n, plot=F)$wc )
LL.ega <- sum( dnorm((e.ega - ega), mean=0, sd=1, log=TRUE) )
LL.cor <- sum( dnorm(Data$ob.cor, mean=rho, sd=exp(sigma), log=TRUE) )
LL <- LL.cor + LL.ega
### Log-Posterior
LP <- LL + Lpp
### Estimates
yhat <- Data$z(rnorm(length(rho), mean=rho, sd=exp(sigma)))
### Output
Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=yhat, parm=parm)
return(Modelout)
}
Model <- compiler::cmpfun(Model)
Initial.Values <- GIV(Model, MyData, PGF=T)
is.model(Model, Initial.Values, MyData)
is.bayesian(Model, Initial.Values, MyData)
Fit <- MAP(Model=Model,Data=MyData, algo="GA")
source("MAP.r")
Fit <- MAP(Model=Model,Data=MyData, algo="GA")
source("GA.r")
Fit <- MAP(Model=Model,Data=MyData, algo="GA")
Fit
Fit$parm
Fit$parm[1:300]
z(Fit$parm[1:300])
rz(Fit$parm[1:300])
ob.corr
ob.cor
cbind(rz(Fit$parm[1:300]), ob.cor)
EGA::EGAnet(vec2mat(rz(Fit$parm[1:300]), 25, 25), n=200)
EGAnet::EGA(vec2mat(rz(Fit$parm[1:300]), 25, 25), n=200)
CORR <- vec2mat(rz(Fit$parm[1:300])
)
CORR <- vec2mat(rz(Fit$parm[1:300]), 25, 25)
colnames(CORR) <- rownames(CORR) <- Data$v.names
EGAnet::EGA(CORR, n=200)
exp(3)
exp(6)
rnorm(1 , 0, exp(6))
rnorm(1 , 5, exp(6))
rnorm(1 , 6, exp(6))
rnorm(1 , 6, exp(6))
rnorm(1 , 6, exp(6))
rnorm(1 , 6, exp(6))
rnorm(1 , 6, exp(6))
rnorm(1 , 6, exp(6))
rnorm(1 , 6, exp(6))
rnorm(1 , 5, exp(6))
rnorm(1 , 5, exp(6))
rnorm(1 , 5, exp(6))
rnorm(1 , 5, exp(6))
rnorm(1 , 5, exp(6))
rnorm(1 , 5, exp(6))
rnorm(1 , 5, exp(6))
rnorm(1 , 5, exp(6))
### Start====
require(LaplacesDemon)
require(compiler)
require(parallel)
require(tidyr)
CPUs = detectCores(all.tests = FALSE, logical = TRUE) - 1
if(CPUs == 0) CPUs = 1
### Convert data to long format====
lonlong <- gather(data.frame(x), item, resp, colnames(x), factor_key=TRUE)
data_long <- data.frame(ID=rep(1:nrow(x), times=ncol(x)),lonlong)
# Assemble data list====
if (method == "MAP") {
mon.names  <- "LL"
} else { mon.names  <- "LP" }
dep = (ncol(x) * (ncol(x) - 1))/2
z   = function(x) .5 * log((1 + x)/(1 - x))
vec2mat = function(x, rows, cols) {
myvec <- x
mycor <- matrix(0,rows,cols)
mycor[ col(mycor) < row(mycor) ] <- myvec
mycor <- mycor + t(mycor)
diag(mycor) <- 1
mycor
}
obs.cor <- mixedCor(x)$rho
ob.cor  <- z(obs.cor[lower.tri(obs.cor)])
rz   = function(x) (exp(2*x) - 1) / (exp(2*x) + 1)
parm.names <- as.parm.names(list( rho=rep(0,dep), sigma=rep(0,dep) ))
pos.rho    <- grep("rho", parm.names)
pos.sigma  <- grep("sigma", parm.names)
PGF <- function(Data) {
rho   <- rnorm(Data$dep)
sigma <- rnorm(Data$dep)
return(c(rho, sigma))
}
MyData <- list(parm.names=parm.names, mon.names=mon.names,
PGF=PGF, X=data_long, n=nrow(x), v=ncol(x), z=z,
dep=dep, ob.cor=ob.cor, pos.rho=pos.rho, v.names=colnames(x),
pos.sigma=pos.sigma, rz=rz, vec2mat=vec2mat)
is.data(MyData)
# Model====
Model <- function(parm, Data){
## Prior parameters
rho   <- parm[Data$pos.rho]
sigma <- parm[Data$pos.sigma]
### Log-Priors
rho.prior   <- sum( dnorm(rho, mean=0, sd=1, log=TRUE) )
sigma.prior <- sum( dgamma(exp(sigma), shape=1e-2, rate=1e-2, log=TRUE) )
Lpp <- rho.prior + sigma.prior
### Log-Likelihood
LL.cor <- sum( dnorm(Data$ob.cor, mean=rho, sd=exp(sigma), log=TRUE) )
LL <- LL.cor
### Log-Posterior
LP <- LL + Lpp
### Estimates
yhat <- Data$z(rnorm(length(rho), mean=rho, sd=exp(sigma)))
### Output
Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP, yhat=yhat, parm=parm)
return(Modelout)
}
Model <- compiler::cmpfun(Model)
Initial.Values <- GIV(Model, MyData, PGF=T)
is.model(Model, Initial.Values, MyData)
is.bayesian(Model, Initial.Values, MyData)
Fit <- MAP(Model=Model,Data=MyData, algo="GA")
CORR <- vec2mat(rz(Fit$parm[1:300]), 25, 25)
colnames(CORR) <- rownames(CORR) <- Data$v.names
EGAnet::EGA(CORR, n=200)
CORR
require(mclust)
GG <- Mclust(CORR)
GG$classification
GG <- Mclust(partial.r(CORR)$rho)
partial.r(CORR)$rho
partial.r(CORR)
GG <- Mclust(partial.r(CORR))
GG$classification
EGAnet::EGA(CORR, n=200)
GG <- EGAnet::EGA(CORR, n=200)
GG <- EGAnet::EGA(CORR, n=200)
GG <- EGAnet::EGA(CORR, n=200)
GG <- EGAnet::EGA(CORR, n=200)
GG$correlation
GG$network
qgraph::qgraph(GG$network)
qgraph::qgraph(GG$network, "directed")
?qqgraph
?qgraph
qgraph::qgraph(GG$network, threshold="fdr")
qgraph::qgraph(GG$network, directed=T)
GG$network[lower.tri(CORR)]
require(pcalg)
?pc
pc.fit <- pc(suffStat = list(C = CORR, n = 200),
indepTest = gaussCItest, ## indep.test: partial correlations
alpha=0.01, labels = v.names, verbose = TRUE)
pc.fit <- pc(suffStat = list(C = CORR, n = 200),
indepTest = gaussCItest, ## indep.test: partial correlations
alpha=0.01, labels = colnames(x), verbose = TRUE)
plot(pc.fit)
pc.fit <- pc(suffStat = list(C = CORR, n = 200),
indepTest = gaussCItest, ## indep.test: partial correlations
alpha=0.05, labels = colnames(x), verbose = TRUE)
plot(pc.fit)
pc.fit <- pc(suffStat = list(C = CORR, n = 200),
indepTest = gaussCItest, ## indep.test: partial correlations
alpha=0.10, labels = colnames(x), verbose = F)
plot(pc.fit)
rm(list=ls())
dev.off()
